This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    deploy.yml
src/
  lib.rs
tests/
  test_simulation.py
www/
  index.html
  index.js
.gitignore
Cargo.toml
LICENSE
pyproject.toml
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="tests/test_simulation.py">
import unittest
import sys
import os

# ãƒ†ã‚¹ãƒˆå®Ÿè¡Œæ™‚ã«ãƒ“ãƒ«ãƒ‰ã•ã‚ŒãŸãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹
# maturin develop ã§ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ¸ˆã¿ã§ã‚ã‚Œã°ä¸è¦ã ãŒã€å¿µã®ãŸã‚
try:
    import context_graph_rs
except ImportError:
    print("Error: context_graph_rs module not found.")
    print("Please run 'maturin develop --features python' first.")
    sys.exit(1)


class TestContextEngine(unittest.TestCase):
    def setUp(self):
        """ãƒ†ã‚¹ãƒˆã”ã¨ã«ã‚¨ãƒ³ã‚¸ãƒ³ã‚’åˆæœŸåŒ–"""
        self.engine = context_graph_rs.ContextEngine()
        print("\n[Setup] Engine Initialized")

    def test_initial_state(self):
        """åˆæœŸçŠ¶æ…‹ã§ã™ã¹ã¦ã®ãƒãƒ¼ãƒ‰ãŒ0ï¼ˆã¾ãŸã¯ä½å€¤ï¼‰ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèª"""
        activations = self.engine.get_activations()
        # é©å½“ãªãƒãƒ¼ãƒ‰ã‚’ãƒã‚§ãƒƒã‚¯
        self.assertLess(activations.get("ST_IDLE", 0.0), 0.1)
        self.assertLess(activations.get("ST_GRASP", 0.0), 0.1)
        print("[Pass] Initial state check")

    def test_grasp_logic(self):
        """
        ãƒ€ãƒŸãƒ¼å…¥åŠ›: å¼·ãæ¡ã£ã¦ã„ã‚‹çŠ¶æ…‹ (FIST=1.0)
        æœŸå¾…ã•ã‚Œã‚‹æŒ™å‹•: FT_HOLDING ãŒä¸ŠãŒã‚Šã€ST_GRASP ãŒæ´»æ€§åŒ–ã™ã‚‹
        """
        # 1. ã‚»ãƒ³ã‚µãƒ¼å…¥åŠ› (Fistã‚’æ¤œçŸ¥)
        sensors = {
            "IN_FIST": 1.0,
            "IN_VEL": 0.1,  # å°‘ã—å‹•ããŒã‚ã‚‹
            "IN_OPEN": 0.0,
        }

        print(f"[Input] Injecting sensors: {sensors}")

        # 2. æ•°ã‚¹ãƒ†ãƒƒãƒ—å®Ÿè¡Œã—ã¦æ‹¡æ•£ã•ã›ã‚‹
        for i in range(5):
            self.engine.inject(sensors)
            self.engine.step()

            # é€”ä¸­çµŒéã®ãƒ­ã‚°
            acts = self.engine.get_activations()
            print(
                f"  Step {i + 1}: FT_HOLDING={acts.get('FT_HOLDING'):.3f}, ST_GRASP={acts.get('ST_GRASP'):.3f}"
            )

        # 3. æ¤œè¨¼
        ranked = self.engine.get_ranked_states()
        top_state = ranked[0]

        print(
            f"[Result] Top State: {top_state['label']} (Value: {top_state['value']:.3f})"
        )

        # æœŸå¾…: ST_GRASP ãŒä¸Šä½ã«æ¥ã¦ã„ã‚‹ã“ã¨
        # (ãƒ­ã‚¸ãƒƒã‚¯ä¸Šã€IN_FIST -> FT_HOLDING -> ST_GRASP ã¨ä¼æ’­ã™ã‚‹)
        self.assertEqual(top_state["id"], "ST_GRASP")
        self.assertGreater(top_state["value"], 0.5)  # 0.5ä»¥ä¸Šã®ç¢ºä¿¡åº¦

    def test_inhibition(self):
        """
        æŠ‘åˆ¶ã®ãƒ†ã‚¹ãƒˆ:
        ST_YES ã¨ ST_NO ã¯ç›¸äº’æŠ‘åˆ¶ã®é–¢ä¿‚ã«ã‚ã‚‹ã€‚
        ST_YES ã‚’æ´»æ€§åŒ–ã•ã›ã‚‹ã¨ã€ST_NO ã¯ä¸‹ãŒã‚Šã«ãããªã‚‹ï¼ˆã‚ã‚‹ã„ã¯ä¸‹ãŒã‚‹ï¼‰ã¯ãšã€‚
        """
        # YESã‚’æ´»æ€§åŒ–ã•ã›ã‚‹å…¥åŠ› (Thumb Up)
        sensors_yes = {"IN_THUMB_UP": 1.0}

        print("[Input] Injecting Thumb Up (Expect YES)")
        for _ in range(5):
            self.engine.inject(sensors_yes)
            self.engine.step()

        acts_yes = self.engine.get_activations()
        val_yes = acts_yes.get("ST_YES", 0.0)
        val_no = acts_yes.get("ST_NO", 0.0)

        print(f"  Result: YES={val_yes:.3f}, NO={val_no:.3f}")

        self.assertGreater(val_yes, val_no)
        self.assertGreater(val_yes, 0.5)


if __name__ == "__main__":
    unittest.main()
</file>

<file path=".gitignore">
# ========================
# Rust / Cargo
# ========================
# ãƒ“ãƒ«ãƒ‰ç”Ÿæˆç‰©ï¼ˆå·¨å¤§ãªã®ã§çµ¶å¯¾ã«ã‚³ãƒŸãƒƒãƒˆã—ãªã„ï¼‰
/target/

# ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ«ãªã©
**/*.rs.bk

# Cargo.lock ã¯ãƒ©ã‚¤ãƒ–ãƒ©ãƒªé–‹ç™ºãªã‚‰ç„¡è¦–ã™ã‚‹ã“ã¨ã‚‚ã‚ã‚Šã¾ã™ãŒã€
# ä»Šå›ã¯ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³/PoCã¨ã—ã¦ã®å†ç¾æ€§ã‚’é‡è¦–ã™ã‚‹ãŸã‚ã‚³ãƒŸãƒƒãƒˆã—ã¾ã™ã€‚
# (ç„¡è¦–ã—ãŸã„å ´åˆã¯ä¸‹ã®è¡Œã® # ã‚’å¤–ã—ã¦ãã ã•ã„)
# Cargo.lock

# ========================
# Python
# ========================
# ãƒã‚¤ãƒˆã‚³ãƒ¼ãƒ‰
__pycache__/
*.py[cod]
*$py.class

# Cæ‹¡å¼µãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ« (Maturinã§ãƒ“ãƒ«ãƒ‰ã•ã‚ŒãŸRustãƒ©ã‚¤ãƒ–ãƒ©ãƒªæœ¬ä½“)
*.so
*.pyd
*.dylib

# é…å¸ƒç”¨ãƒ“ãƒ«ãƒ‰ã‚¢ãƒ¼ãƒ†ã‚£ãƒ•ã‚¡ã‚¯ãƒˆ
dist/
build/
*.egg-info/

# ä»®æƒ³ç’°å¢ƒ (uv venv)
.venv/
venv/
env/
ENV/

# ãƒ†ã‚¹ãƒˆãƒ»å‹ãƒã‚§ãƒƒã‚¯ã‚­ãƒ£ãƒƒã‚·ãƒ¥
.pytest_cache/
.mypy_cache/

# ========================
# WebAssembly / Frontend
# ========================
# wasm-pack ã«ã‚ˆã£ã¦è‡ªå‹•ç”Ÿæˆã•ã‚Œã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ç¾¤
# (ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‹ã‚‰ã„ã¤ã§ã‚‚å†ç”Ÿæˆã§ãã‚‹ãŸã‚ã‚³ãƒŸãƒƒãƒˆä¸è¦)
www/pkg/

# npm ã‚’ä½¿ã†ã‚ˆã†ã«ãªã£ãŸå ´åˆã®ä¾å­˜ãƒ©ã‚¤ãƒ–ãƒ©ãƒª
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# ========================
# OS / IDE / Editors
# ========================
# macOS
.DS_Store

# Windows
Thumbs.db
ehthumbs.db

# VS Code
.vscode/

# IntelliJ / PyCharm
.idea/

# Vim / Emacs
*~
*.swp
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 Funmatu

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path=".github/workflows/deploy.yml">
name: Deploy to GitHub Pages

on:
  # mainãƒ–ãƒ©ãƒ³ãƒã«pushã•ã‚ŒãŸã‚‰å®Ÿè¡Œ
  push:
    branches: ["main"]
  # ãƒ–ãƒ©ã‚¦ã‚¶ã‹ã‚‰æ‰‹å‹•ã§å®Ÿè¡Œã—ãŸã„æ™‚ç”¨
  workflow_dispatch:

permissions:
  contents: write # gh-pagesãƒ–ãƒ©ãƒ³ãƒã¸ã®æ›¸ãè¾¼ã¿æ¨©é™

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      # Rustç’°å¢ƒã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ— (ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚‚åŠ¹ãç¾ä»£çš„ãªAction)
      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: wasm32-unknown-unknown

      # wasm-packã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
      - name: Install wasm-pack
        run: curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh

      # ãƒ“ãƒ«ãƒ‰å®Ÿè¡Œ (Releaseãƒ¢ãƒ¼ãƒ‰ã§æœ€é©åŒ–)
      - name: Build WASM
        # ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰æ§‹æˆãªã®ã§ã€Webç”¨ãƒ•ãƒ©ã‚°(--features wasm)ã‚’æ˜ç¤ºçš„ã«ONã«ã™ã‚‹
        run: wasm-pack build --target web --out-dir www/pkg --no-default-features --features wasm
      
      # CIã‚µãƒ¼ãƒãƒ¼ä¸Šã§ã®ã¿ ãƒ«ãƒ¼ãƒˆã¨ã€pkgå†…éƒ¨ã®gitignoreã®ä¸¡æ–¹ã‚’æŠ¹æ®ºã™ã‚‹ã€‚
      # ã“ã‚Œã«ã‚ˆã‚Šã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ­ãƒ¼ã‚«ãƒ«ç’°å¢ƒã¯æ±šã•ãšã«ã€ç”Ÿæˆã•ã‚ŒãŸ pkg ãƒ•ã‚©ãƒ«ãƒ€ã‚’å¼·åˆ¶çš„ã«èªè­˜ã•ã›ã‚‹ã€‚
      - name: Remove .gitignore to allow deploying pkg
        run: |
          rm -f .gitignore
          rm -f www/pkg/.gitignore
      
      # Jekyllå‡¦ç†ã‚’ç„¡åŠ¹åŒ–ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆ
      - name: Create .nojekyll
        run: touch www/.nojekyll

      # GitHub Pagesã¸ã®ãƒ‡ãƒ—ãƒ­ã‚¤
      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./www # ã“ã®ãƒ•ã‚©ãƒ«ãƒ€ã®ä¸­èº«ã‚’å…¬é–‹ã™ã‚‹
          force_orphan: true # å±¥æ­´ã‚’æºœã‚è¾¼ã¾ãšã€å¸¸ã«æœ€æ–°ç‰ˆã ã‘ã§ä¸Šæ›¸ãã™ã‚‹ï¼ˆè»½é‡åŒ–ï¼‰

# ======================================================================================
#  [Reference] Python CI Job
#  å°†æ¥çš„ã«Pythonãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®è‡ªå‹•ãƒ†ã‚¹ãƒˆãŒå¿…è¦ã«ãªã£ãŸå ´åˆã€ä»¥ä¸‹ã®ã‚³ãƒ¡ãƒ³ãƒˆã‚’è§£é™¤ã—ã¦jobsã«è¿½åŠ ã—ã¦ãã ã•ã„ã€‚
#  (ãƒ­ãƒ¼ã‚«ãƒ«ã®UVç’°å¢ƒã§ååˆ†ãªå ´åˆã¯ä¸è¦ã§ã™)
# ======================================================================================
#   test-python:
#     runs-on: ubuntu-latest
#     steps:
#       - uses: actions/checkout@v4
#
#       - name: Set up Python
#         uses: actions/setup-python@v5
#         with:
#           python-version: '3.10'
#
#       # Pythonå´ã§ã‚‚Rustã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯å¿…è¦
#       - name: Install Rust
#         uses: dtolnay/rust-toolchain@stable
#
#       - name: Install Maturin
#         run: pip install maturin
#
#       - name: Build and Test Python Module
#         # Releaseãƒ“ãƒ«ãƒ‰ã§ãƒ†ã‚¹ãƒˆã™ã‚‹å ´åˆã€--release ã‚’è¿½åŠ ã—ã¦ãã ã•ã„
#         run: |
#           maturin develop --features python
#           python -c "import context_graph_rs; print(f'Test Result: {context_graph_rs.compute_metrics(1000, 1.0)}')"
</file>

<file path="www/index.html">
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CONTEXTGRAPH.V6.0 - RUST CORE</title>
    
    <script src="https://cdn.tailwindcss.com"></script>

    <script type="importmap">
    {
        "imports": {
            "react": "https://esm.sh/react@18.2.0",
            "react-dom": "https://esm.sh/react-dom@18.2.0",
            "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
            "recharts": "https://esm.sh/recharts@2.12.0?external=react,react-dom",
            "lucide-react": "https://esm.sh/lucide-react@0.330.0?external=react,react-dom"
        }
    }
    </script>

    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js" crossorigin="anonymous"></script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.26.0/cytoscape.min.js"></script>

    <style>
        body { margin: 0; background-color: #020617; color: #f8fafc; font-family: 'Courier New', monospace; overflow: hidden; }
        .cy-container { height: 100%; width: 100%; position: absolute; top: 0; left: 0; }
        .recharts-wrapper { width: 100% !important; height: 100% !important; }
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #0f172a; }
        ::-webkit-scrollbar-thumb { background: #334155; border-radius: 3px; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module" src="./index.js"></script>
</body>
</html>
</file>

<file path="www/index.js">
import React, { useState, useEffect, useRef } from 'react';
import { createRoot } from 'react-dom/client';
import { LineChart, Line, Tooltip, ResponsiveContainer, CartesianGrid, YAxis } from 'recharts';
import { Camera, Activity, Network, Brain, Zap, ScanFace, Hand, Ghost } from 'lucide-react';

// Import WASM (init function and ContextEngine class)
import init, { ContextEngine } from './pkg/context_graph_rs.js';

// --- Graph Definitions (Visualization Only) ---
// Note: Logic is in Rust, but coordinates/labels are needed for Cytoscape drawing.
const GRAPH_NODES = [
    { id: 'IN_VEL', label: 'Velocity', type: 'SENSOR', x: 0, y: 0 },
    { id: 'IN_REL_MOV', label: 'Rel. Motion', type: 'SENSOR', x: 0, y: 40 },
    { id: 'IN_FIST', label: 'Fist', type: 'SENSOR', x: 0, y: 80 },
    { id: 'IN_PINCH', label: 'Pinch', type: 'SENSOR', x: 0, y: 120 },
    { id: 'IN_OPEN', label: 'Open Hand', type: 'SENSOR', x: 0, y: 160 },
    { id: 'IN_SCISSORS', label: 'Scissors Pose', type: 'SENSOR', x: 0, y: 200 },
    { id: 'IN_HANDS_PROX', label: 'Hands Touch', type: 'SENSOR', x: 0, y: 240 },
    { id: 'IN_OCCLUSION', label: 'Face Lost+Prox', type: 'SENSOR', x: 0, y: 280 },
    { id: 'IN_THUMB_UP', label: 'Thumb UP', type: 'SENSOR', x: 0, y: 340 },
    { id: 'IN_THUMB_DOWN', label: 'Thumb DOWN', type: 'SENSOR', x: 0, y: 380 },
    { id: 'IN_EYES_ACT', label: 'Cover Eyes', type: 'SENSOR', x: 0, y: 440 },
    { id: 'IN_EARS_ACT', label: 'Cover Ears', type: 'SENSOR', x: 0, y: 480 },
    { id: 'IN_MOUTH_GUARD', label: 'Cover Mouth', type: 'SENSOR', x: 0, y: 520 },
    { id: 'IN_SMILE', label: 'Smile', type: 'SENSOR', x: 0, y: 580 },
    { id: 'IN_MOUTH', label: 'Mouth Open', type: 'SENSOR', x: 0, y: 620 },
    { id: 'IN_FACE_PROX', label: 'Hand-Face Prox', type: 'SENSOR', x: 0, y: 660 },

    { id: 'FT_ACTIVE', label: 'High Kinetic', type: 'FEATURE', x: 250, y: 20 },
    { id: 'FT_HOLDING', label: 'Holding', type: 'FEATURE', x: 250, y: 100 },
    { id: 'FT_FRICTION', label: 'Friction', type: 'FEATURE', x: 250, y: 240 },
    { id: 'FT_HIDING', label: 'Concealment', type: 'FEATURE', x: 250, y: 300 },
    { id: 'FT_RPS_ROCK', label: 'Pose: ROCK', type: 'FEATURE', x: 250, y: 160 },
    { id: 'FT_RPS_SCI', label: 'Pose: SCISSORS', type: 'FEATURE', x: 250, y: 200 },
    { id: 'FT_RPS_PAP', label: 'Pose: PAPER', type: 'FEATURE', x: 250, y: 280 },
    { id: 'FT_APPROVAL', label: 'Semantics: YES', type: 'FEATURE', x: 250, y: 340 },
    { id: 'FT_DISAPPROVAL', label: 'Semantics: NO', type: 'FEATURE', x: 250, y: 380 },
    { id: 'FT_HIDDEN_SENSE', label: 'Blocking Senses', type: 'FEATURE', x: 250, y: 480 },
    { id: 'FT_HAPPY', label: 'Emo: Happy', type: 'FEATURE', x: 250, y: 580 },
    { id: 'FT_SHOCK', label: 'Emo: Shock', type: 'FEATURE', x: 250, y: 620 },

    { id: 'ST_IDLE', label: 'IDLE', type: 'STATE', x: 600, y: 0 },
    { id: 'ST_GRASP', label: 'ACTION: GRASP', type: 'STATE', x: 600, y: 80 },
    { id: 'ST_DRAG', label: 'ACTION: DRAG', type: 'STATE', x: 600, y: 120 },
    { id: 'ST_WASH', label: 'ACTION: WASH', type: 'STATE', x: 600, y: 240 },
    { id: 'ST_PEEKABOO', label: 'CTX: HIDDEN', type: 'STATE', x: 600, y: 300 },
    { id: 'ST_ROCK', label: 'GAME: ROCK', type: 'STATE', x: 600, y: 160 },
    { id: 'ST_SCISSORS', label: 'GAME: SCISSORS', type: 'STATE', x: 600, y: 200 },
    { id: 'ST_PAPER', label: 'GAME: PAPER', type: 'STATE', x: 600, y: 280 },
    { id: 'ST_YES', label: 'CTX: YES / OK', type: 'STATE', x: 600, y: 340 },
    { id: 'ST_NO', label: 'CTX: NO / BAD', type: 'STATE', x: 600, y: 380 },
    { id: 'ST_MIZARU', label: 'ğŸ™ˆ MIZARU', type: 'STATE', x: 600, y: 440 },
    { id: 'ST_KIKAZARU', label: 'ğŸ™‰ KIKAZARU', type: 'STATE', x: 600, y: 480 },
    { id: 'ST_IWAZARU', label: 'ğŸ™Š IWAZARU', type: 'STATE', x: 600, y: 520 },
    { id: 'ST_SMILE', label: 'FACE: SMILE', type: 'STATE', x: 600, y: 580 },
    { id: 'ST_SURPRISE', label: 'FACE: SURPRISE', type: 'STATE', x: 600, y: 620 },
];

const GRAPH_EDGES = [
    { source: 'IN_VEL', target: 'FT_ACTIVE', weight: 0.9 },
    { source: 'IN_FIST', target: 'FT_HOLDING', weight: 0.9 },
    { source: 'IN_PINCH', target: 'FT_HOLDING', weight: 0.8 },
    { source: 'IN_HANDS_PROX', target: 'FT_FRICTION', weight: 0.7 },
    { source: 'IN_REL_MOV', target: 'FT_FRICTION', weight: 0.9 },
    { source: 'IN_OCCLUSION', target: 'FT_HIDING', weight: 1.0 },
    { source: 'FT_HOLDING', target: 'ST_GRASP', weight: 1.0 },
    { source: 'FT_ACTIVE', target: 'ST_GRASP', weight: -0.3 },
    { source: 'FT_HOLDING', target: 'ST_DRAG', weight: 0.8 },
    { source: 'FT_ACTIVE', target: 'ST_DRAG', weight: 0.9 },
    { source: 'FT_FRICTION', target: 'ST_WASH', weight: 1.2 },
    { source: 'FT_HIDING', target: 'ST_PEEKABOO', weight: 1.2 },
    { source: 'IN_FIST', target: 'FT_RPS_ROCK', weight: 0.8 },
    { source: 'IN_SCISSORS', target: 'FT_RPS_SCI', weight: 0.9 },
    { source: 'IN_OPEN', target: 'FT_RPS_PAP', weight: 0.9 },
    { source: 'FT_RPS_ROCK', target: 'ST_ROCK', weight: 0.9 },
    { source: 'FT_RPS_SCI', target: 'ST_SCISSORS', weight: 0.9 },
    { source: 'FT_RPS_PAP', target: 'ST_PAPER', weight: 0.9 },
    { source: 'IN_THUMB_UP', target: 'FT_APPROVAL', weight: 1.0 },
    { source: 'IN_THUMB_DOWN', target: 'FT_DISAPPROVAL', weight: 1.0 },
    { source: 'IN_THUMB_UP', target: 'FT_RPS_ROCK', weight: -0.5 },
    { source: 'IN_THUMB_DOWN', target: 'FT_RPS_ROCK', weight: -0.5 },
    { source: 'FT_APPROVAL', target: 'ST_YES', weight: 1.0 },
    { source: 'FT_DISAPPROVAL', target: 'ST_NO', weight: 1.0 },
    { source: 'IN_EYES_ACT', target: 'FT_HIDDEN_SENSE', weight: 0.8 },
    { source: 'IN_EYES_ACT', target: 'ST_MIZARU', weight: 1.0 },
    { source: 'IN_HANDS_PROX', target: 'ST_MIZARU', weight: 0.5 },
    { source: 'IN_EARS_ACT', target: 'FT_HIDDEN_SENSE', weight: 0.8 },
    { source: 'IN_EARS_ACT', target: 'ST_KIKAZARU', weight: 1.0 },
    { source: 'IN_MOUTH_GUARD', target: 'FT_HIDDEN_SENSE', weight: 0.8 },
    { source: 'IN_MOUTH_GUARD', target: 'ST_IWAZARU', weight: 1.0 },
    { source: 'IN_HANDS_PROX', target: 'ST_IWAZARU', weight: 0.8 },
    { source: 'IN_SMILE', target: 'FT_HAPPY', weight: 0.9 },
    { source: 'IN_MOUTH', target: 'FT_SHOCK', weight: 0.6 },
    { source: 'IN_FACE_PROX', target: 'FT_SHOCK', weight: 0.5 },
    { source: 'FT_HAPPY', target: 'ST_SMILE', weight: 0.9 },
    { source: 'FT_SHOCK', target: 'ST_SURPRISE', weight: 0.9 },
    { source: 'FT_ACTIVE', target: 'ST_IDLE', weight: -0.6 },
    { source: 'ST_ROCK', target: 'ST_SCISSORS', weight: -0.8 },
    { source: 'ST_ROCK', target: 'ST_PAPER', weight: -0.8 },
    { source: 'ST_SCISSORS', target: 'ST_PAPER', weight: -0.8 },
    { source: 'ST_YES', target: 'ST_NO', weight: -2.0 },
    { source: 'ST_NO', target: 'ST_YES', weight: -2.0 },
    { source: 'ST_MIZARU', target: 'ST_KIKAZARU', weight: -1.0 },
    { source: 'ST_MIZARU', target: 'ST_IWAZARU', weight: -1.0 },
    { source: 'ST_KIKAZARU', target: 'ST_IWAZARU', weight: -1.0 },
    { source: 'ST_GRASP', target: 'ST_WASH', weight: -0.8 },
    { source: 'ST_WASH', target: 'ST_GRASP', weight: -0.8 },
    { source: 'ST_DRAG', target: 'ST_WASH', weight: -0.8 },
];

// --- JS Utility for SMA Buffer ---
class SensorBuffer {
    constructor(size = 5) {
        this.size = size;
        this.buffer = {};
    }
    add(key, val) {
        if (!this.buffer[key]) this.buffer[key] = [];
        this.buffer[key].push(val);
        if (this.buffer[key].length > this.size) this.buffer[key].shift();
    }
    getAverage(key) {
        if (!this.buffer[key] || this.buffer[key].length === 0) return 0;
        const sum = this.buffer[key].reduce((a, b) => a + b, 0);
        return sum / this.buffer[key].length;
    }
}

const LogicGraphApp = () => {
    const videoRef = useRef(null);
    const canvasRef = useRef(null);
    const graphContainerRef = useRef(null);
    const cyRef = useRef(null);
    
    // Rust Engine Reference
    const engineRef = useRef(null);
    
    const bufferRef = useRef(new SensorBuffer(5));
    const memoryRef = useRef({ faceVisible: false, lastHandFaceDist: 1.0, framesLost: 0 });
    const prevPoseRef = useRef(null);

    const [rankedStates, setRankedStates] = useState([]);
    const [history, setHistory] = useState([]);
    const [isCameraReady, setIsCameraReady] = useState(false);
    const [isWasmReady, setIsWasmReady] = useState(false);

    const drawHandSkeleton = (ctx, landmarks, w, h, color) => {
        const connect = (i, j) => {
            const p1 = landmarks[i]; const p2 = landmarks[j];
            ctx.beginPath(); ctx.moveTo(p1.x * w, p1.y * h); ctx.lineTo(p2.x * w, p2.y * h); ctx.stroke();
        };
        ctx.strokeStyle = color; ctx.lineWidth = 2;
        [[0,1,2,3,4],[0,5,6,7,8],[0,9,10,11,12],[0,13,14,15,16],[0,17,18,19,20]].forEach(chain => {
            for(let k=0; k<chain.length-1; k++) connect(chain[k], chain[k+1]);
        });
        ctx.fillStyle = color;
        [4,8,12,16,20].forEach(i => {
            ctx.beginPath(); ctx.arc(landmarks[i].x * w, landmarks[i].y * h, 3, 0, 2 * Math.PI); ctx.fill();
        });
    };

    // --- Initialization ---
    useEffect(() => {
        const startSystem = async () => {
            // 1. Load WASM
            await init();
            engineRef.current = new ContextEngine();
            setIsWasmReady(true);

            // 2. Setup Cytoscape
            if (graphContainerRef.current) {
                const nodes = GRAPH_NODES.map(n => ({
                    data: { id: n.id, label: n.label, type: n.type },
                    position: { x: n.x, y: n.y },
                    classes: n.type
                }));
                const edges = GRAPH_EDGES.map(e => ({
                    data: { id: `${e.source}-${e.target}`, source: e.source, target: e.target, weight: e.weight }
                }));
                
                cyRef.current = cytoscape({
                    container: graphContainerRef.current,
                    elements: [...nodes, ...edges],
                    style: [
                        { selector: 'node', style: { 'label': 'data(label)', 'color': '#e2e8f0', 'font-size': '8px', 'background-color': '#334155', 'text-valign': 'center', 'text-halign': 'center', 'border-color': '#fff', 'border-width': 1, 'transition-property': 'background-color, width, height, border-width, opacity', 'transition-duration': 100 } },
                        { selector: '.STATE', style: { 'shape': 'rectangle', 'width': 60, 'height': 25, 'background-color': '#475569' } },
                        { selector: '.SENSOR', style: { 'shape': 'diamond', 'width': 25, 'height': 25, 'background-color': '#0ea5e9' } },
                        { selector: '.FEATURE', style: { 'shape': 'ellipse', 'width': 30, 'height': 30, 'background-color': '#8b5cf6' } },
                        { selector: 'edge', style: { 'width': 1, 'line-color': '#334155', 'target-arrow-shape': 'triangle', 'arrow-scale': 0.8 } }
                    ],
                    layout: { name: 'preset' },
                    userZoomingEnabled: true,
                    minZoom: 0.5,
                    maxZoom: 2.0
                });
                cyRef.current.fit(undefined, 30);
            }

            // 3. Setup MediaPipe
            if (videoRef.current && window.Holistic && window.Camera) {
                try {
                    const holistic = new window.Holistic({
                        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`
                    });
                    holistic.setOptions({ modelComplexity: 1, smoothLandmarks: true, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
                    holistic.onResults(onResults);
                    const camera = new window.Camera(videoRef.current, {
                        onFrame: async () => { await holistic.send({ image: videoRef.current }); },
                        width: 640, height: 360
                    });
                    camera.start();
                    setIsCameraReady(true);
                } catch (err) {
                    console.error("Camera Init Failed", err);
                }
            }
        };
        startSystem();
    }, []);

    const onResults = (results) => {
        // --- 1. Draw Canvas ---
        const canvas = canvasRef.current;
        const ctx = canvas?.getContext('2d');
        if (canvas && ctx) {
            ctx.save();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
            if (results.rightHandLandmarks) drawHandSkeleton(ctx, results.rightHandLandmarks, canvas.width, canvas.height, '#34d399');
            if (results.leftHandLandmarks) drawHandSkeleton(ctx, results.leftHandLandmarks, canvas.width, canvas.height, '#34d399');
            // Face points (simplified)
            if (results.faceLandmarks) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                [33, 263, 234, 454, 13, 14].forEach(i => {
                    const lm = results.faceLandmarks[i];
                    ctx.beginPath(); ctx.arc(lm.x * canvas.width, lm.y * canvas.height, 2, 0, 2 * Math.PI); ctx.fill();
                });
            }
            ctx.restore();
        }

        // --- 2. Calculate Sensors (JS Logic) ---
        const sensors = {
            'IN_VEL': 0, 'IN_REL_MOV': 0, 'IN_FIST': 0, 'IN_PINCH': 0, 'IN_OPEN': 0, 
            'IN_SCISSORS': 0, 'IN_HANDS_PROX': 0, 'IN_OCCLUSION': 0,
            'IN_THUMB_UP': 0, 'IN_THUMB_DOWN': 0,
            'IN_EYES_ACT': 0, 'IN_EARS_ACT': 0, 'IN_MOUTH_GUARD': 0,
            'IN_SMILE': 0, 'IN_MOUTH': 0, 'IN_FACE_PROX': 0
        };

        const activeHand = results.rightHandLandmarks || results.leftHandLandmarks;
        const bothHands = results.rightHandLandmarks && results.leftHandLandmarks;
        const mem = memoryRef.current;
        let handCenter = {x:0, y:0};
        let activeHandsCount = 0;

        if (activeHand) {
            const processHand = (lm) => {
                const wrist = lm[0];
                handCenter.x += wrist.x;
                handCenter.y += wrist.y;
                activeHandsCount++;

                let bentCount = 0;
                const bentState = [false, false, false, false];
                const tips = [8, 12, 16, 20];
                const mcps = [5, 9, 13, 17];
                
                tips.forEach((t, i) => {
                    const dTip = Math.hypot(lm[t].x - wrist.x, lm[t].y - wrist.y);
                    const dMcp = Math.hypot(lm[mcps[i]].x - wrist.x, lm[mcps[i]].y - wrist.y);
                    if (dTip < dMcp * 1.1) { bentCount++; bentState[i] = true; }
                });
                
                const thumbTip = lm[4];
                const pinkyMcp = lm[17];
                const isThumbBent = Math.hypot(thumbTip.x - pinkyMcp.x, thumbTip.y - pinkyMcp.y) < 0.15;
                if (isThumbBent) bentCount++;

                if (bentCount >= 5) sensors.IN_FIST = 1.0;
                else if (bentCount <= 1 && !isThumbBent) sensors.IN_OPEN = 1.0;
                
                if (!bentState[0] && !bentState[1] && bentState[2] && bentState[3]) sensors.IN_SCISSORS = 1.0;

                const indexTip = lm[8];
                if (Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y) < 0.05) sensors.IN_PINCH = 1.0;

                if (bentCount >= 4 && !isThumbBent) {
                    const thumbMcp = lm[2];
                    if (thumbTip.y < thumbMcp.y - 0.05) sensors.IN_THUMB_UP = 1.0;
                    else if (thumbTip.y > thumbMcp.y + 0.05) sensors.IN_THUMB_DOWN = 1.0;
                }

                if (results.faceLandmarks) {
                    const nose = results.faceLandmarks[1];
                    const dist = Math.hypot(wrist.x - nose.x, wrist.y - nose.y);
                    sensors.IN_FACE_PROX = Math.max(0, 1 - (dist / 0.25));
                }
            };

            if (results.rightHandLandmarks) processHand(results.rightHandLandmarks);
            if (results.leftHandLandmarks) processHand(results.leftHandLandmarks);

            // Velocity
            handCenter.x /= activeHandsCount;
            handCenter.y /= activeHandsCount;
            if (prevPoseRef.current) {
                const dist = Math.hypot(handCenter.x - prevPoseRef.current.x, handCenter.y - prevPoseRef.current.y);
                const rawVel = dist * 30;
                sensors.IN_VEL = Math.min(1, Math.max(0, (rawVel - 0.05) * 2));
            }
            prevPoseRef.current = { x: handCenter.x, y: handCenter.y };
        } else {
            prevPoseRef.current = null;
        }

        if (bothHands && results.faceLandmarks) {
            const rw = results.rightHandLandmarks[0];
            const lw = results.leftHandLandmarks[0];
            const face = results.faceLandmarks;
            const handDist = Math.hypot(rw.x - lw.x, rw.y - lw.y);
            if (handDist < 0.15) sensors.IN_HANDS_PROX = 1.0;
            
            if (sensors.IN_HANDS_PROX && sensors.IN_VEL > 0.2) sensors.IN_REL_MOV = 1.0;

            const leftEye = face[33]; const rightEye = face[263];
            const dLE = Math.hypot(lw.x - leftEye.x, lw.y - leftEye.y);
            const dRE = Math.hypot(rw.x - rightEye.x, rw.y - rightEye.y);
            const eyesProx = (dLE < 0.15 || Math.hypot(rw.x - leftEye.x, rw.y - leftEye.y) < 0.15) && 
                             (dRE < 0.15 || Math.hypot(lw.x - rightEye.x, lw.y - rightEye.y) < 0.15);
            if (eyesProx && sensors.IN_HANDS_PROX > 0.4) sensors.IN_EYES_ACT = 1.0;

            const leftEar = face[234]; const rightEar = face[454];
            const dEarL = Math.hypot(lw.x - leftEar.x, lw.y - leftEar.y);
            const dEarR = Math.hypot(rw.x - rightEar.x, rw.y - rightEar.y);
            if (dEarL < 0.2 && dEarR < 0.2) sensors.IN_EARS_ACT = 1.0;

            const mouth = face[13];
            const dMouthL = Math.hypot(lw.x - mouth.x, lw.y - mouth.y);
            const dMouthR = Math.hypot(rw.x - mouth.x, rw.y - mouth.y);
            if (dMouthL < 0.15 && dMouthR < 0.15 && sensors.IN_HANDS_PROX > 0.4) sensors.IN_MOUTH_GUARD = 1.0;
        }

        if (results.faceLandmarks) {
            const face = results.faceLandmarks;
            const upper = face[13]; const lower = face[14];
            const mouthH = Math.hypot(upper.x - lower.x, upper.y - lower.y);
            sensors.IN_MOUTH = Math.min(1, Math.max(0, (mouthH - 0.01) * 20));

            const leftC = face[61]; const rightC = face[291];
            const width = Math.hypot(leftC.x - rightC.x, leftC.y - rightC.y);
            if (width > 0.15) sensors.IN_SMILE = Math.min(1, (width - 0.15) * 10);

            const nose = face[1];
            if (activeHandsCount > 0) {
                mem.lastHandFaceDist = Math.hypot(handCenter.x - nose.x, handCenter.y - nose.y);
            }
            mem.faceVisible = true;
            mem.framesLost = 0;
        } else {
            if (mem.faceVisible) {
                 mem.framesLost++;
                 if (mem.framesLost < 30) { 
                    if (mem.lastHandFaceDist < 0.2) sensors.IN_OCCLUSION = 1.0; 
                 } else {
                     mem.faceVisible = false;
                 }
            }
        }

        // Buffer Smoothing
        Object.keys(sensors).forEach(k => {
            bufferRef.current.add(k, sensors[k]);
            sensors[k] = bufferRef.current.getAverage(k);
        });

        // --- 3. Rust Engine Execution ---
        if (engineRef.current) {
            const engine = engineRef.current;
            engine.inject(sensors);
            engine.step();
            
            const activations = engine.get_activations();
            const ranked = engine.get_ranked_states();
            
            setRankedStates(ranked);

            // History Update (Throttled)
            if (Math.random() > 0.85) {
                setHistory(prev => [...prev, { time: Date.now(), ...activations }].slice(-50));
            }

            // Cytoscape Update
            if (cyRef.current) {
                cyRef.current.batch(() => {
                    Object.entries(activations).forEach(([id, val]) => {
                        const el = cyRef.current.$(`#${id}`);
                        if (el && el.length > 0) {
                            const intensity = Math.floor(val * 255);
                            let color = '';
                            if (id.startsWith('ST_')) {
                                if (id.includes('MIZARU') || id.includes('KIKAZARU') || id.includes('IWAZARU')) color = '#a855f7';
                                else if (id.includes('YES')) color = '#4ade80';
                                else if (id.includes('NO')) color = '#f87171';
                                else if (id.includes('GRASP') || id.includes('DRAG') || id.includes('WASH')) color = '#facc15'; 
                                else if (id.includes('PEEKABOO')) color = '#f472b6';
                                else color = val > 0.5 ? '#f59e0b' : '#64748b';
                            } else if (id.startsWith('FT_')) {
                                color = `rgb(${100+intensity/2}, ${50}, ${200+intensity/5})`;
                            } else {
                                color = `rgb(0, ${intensity}, ${255})`;
                            }
                            el.style({
                                'background-color': color,
                                'border-width': 1 + val * 3,
                                'width': (id.startsWith('ST') ? 60 : 25) + (val * 10),
                                'height': (id.startsWith('ST') ? 25 : 25) + (val * 10),
                                'opacity': 0.3 + (val * 0.7),
                                'z-index': val > 0.5 ? 100 : 0
                            });
                        }
                    });
                    
                    GRAPH_EDGES.forEach(edge => {
                        const sourceVal = activations[edge.source] || 0;
                        const edgeEl = cyRef.current.$(`#${edge.source}-${edge.target}`);
                        if (edgeEl && edgeEl.length > 0) {
                            const active = sourceVal > 0.1;
                            edgeEl.style({
                                'width': active ? 0.5 + sourceVal * 3 : 0.2,
                                'line-color': active ? '#a78bfa' : '#1e293b',
                                'target-arrow-color': active ? '#a78bfa' : '#1e293b',
                                'opacity': active ? 0.6 : 0.1
                            });
                        }
                    });
                });
            }
        }
    };

    const winner = rankedStates.length > 0 ? rankedStates[0] : { label: 'INIT', value: 0, id: 'INIT' };
    const isConfident = winner.value > 0.55;

    return (
        <div className="h-screen flex flex-col p-4 gap-4 overflow-hidden bg-slate-950 text-slate-100 font-mono">
            <header className="flex justify-between items-center border-b border-slate-800 pb-2 shrink-0">
                <div className="flex items-center gap-2">
                    <Brain className="text-purple-400" />
                    <h1 className="text-xl font-bold tracking-wider">
                        CONTEXT<span className="text-purple-400">GRAPH</span>.RS <span className="text-xs text-green-400 ml-2">WASM CORE</span>
                    </h1>
                </div>
                <div className="text-xs text-slate-500 flex gap-4 hidden md:flex">
                    <span className="flex items-center gap-1"><ScanFace size={14} /> V4 SEMANTICS</span>
                    <span className="flex items-center gap-1"><Hand size={14} /> V5 PHYSICS</span>
                    <span className="flex items-center gap-1"><Zap size={14} /> RUST ENGINE</span>
                    <span className="flex items-center gap-1"><Ghost size={14} /> PERMANENCE</span>
                </div>
            </header>

            <div className="flex-1 grid grid-cols-1 lg:grid-cols-12 gap-4 overflow-hidden min-h-0">
                <div className="col-span-1 lg:col-span-4 flex flex-col gap-4 min-h-0">
                    <div className="relative aspect-video bg-black rounded border border-slate-800 shrink-0 overflow-hidden shadow-2xl">
                        <div className="absolute top-2 left-2 z-10 bg-black/60 px-2 py-1 rounded text-xs text-purple-300 flex items-center gap-2 backdrop-blur-sm border border-purple-500/30">
                            <Camera size={12} /> SENSOR INPUT
                        </div>
                        <video ref={videoRef} className="absolute inset-0 w-full h-full object-cover opacity-0" playsInline muted />
                        <canvas ref={canvasRef} className="w-full h-full object-cover transform -scale-x-100" width="640" height="360" />
                        {!isCameraReady && <div className="absolute inset-0 flex items-center justify-center text-slate-500 text-xs animate-pulse">INITIALIZING SYSTEM...</div>}
                    </div>
                    
                    <div className="bg-slate-900/50 p-4 rounded border border-slate-800 flex-1 flex flex-col overflow-hidden relative">
                        <div className="text-xs text-slate-500 mb-2 tracking-widest uppercase flex justify-between">
                            <span>Dominant Context</span>
                            <span>Confidence: {(winner.value * 100).toFixed(0)}%</span>
                        </div>
                        <div className={`text-3xl font-black mb-6 transition-all duration-300 ${
                            isConfident ? 
                            (winner.id.includes('YES') ? 'text-green-400' : 
                             winner.id.includes('NO') ? 'text-red-400' : 
                             winner.id.includes('MIZARU') || winner.id.includes('KIKAZARU') || winner.id.includes('IWAZARU') ? 'text-purple-400 animate-pulse' :
                             winner.id.includes('PEEKABOO') ? 'text-pink-400' :
                             winner.id.includes('GRASP') || winner.id.includes('DRAG') ? 'text-orange-400' :
                             winner.id.includes('SURPRISE') ? 'text-yellow-400' : 'text-blue-400') 
                             : 'text-slate-600 blur-[1px]'
                        }`}>
                            {isConfident ? winner.label : "ANALYZING..."}
                        </div>
                        <div className="flex-1 overflow-y-auto pr-2 space-y-3">
                            <div className="text-[10px] text-slate-500 uppercase border-b border-slate-800 pb-1 mb-2">Context Candidates</div>
                            {rankedStates.slice(0, 8).map((state, idx) => (
                                <div key={state.id} className="group flex items-center gap-3">
                                    <div className="w-6 text-right text-xs text-slate-500 font-mono">#{idx+1}</div>
                                    <div className="flex-1">
                                        <div className="flex justify-between text-xs mb-1">
                                            <span className={idx === 0 ? 'text-white font-bold' : 'text-slate-400'}>{state.label}</span>
                                            <span className="text-slate-500 font-mono">{(state.value).toFixed(2)}</span>
                                        </div>
                                        <div className="h-1.5 bg-slate-800 rounded-full overflow-hidden">
                                            <div className={`h-full rounded-full transition-all duration-300 ${idx === 0 ? 'bg-purple-500' : 'bg-slate-600'}`} style={{width: `${state.value * 100}%`}}></div>
                                        </div>
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                </div>

                <div className="col-span-1 lg:col-span-8 flex flex-col gap-4 min-h-0">
                    <div className="flex-1 bg-slate-900 rounded border border-slate-800 relative min-h-[300px] overflow-hidden">
                        <div className="absolute top-2 right-2 z-10 bg-black/60 px-2 py-1 rounded text-xs text-purple-300 flex items-center gap-2 backdrop-blur-sm border border-purple-500/30">
                            <Network size={12} /> SEMANTIC + PHYSICAL NETWORK
                        </div>
                        <div ref={graphContainerRef} className="cy-container" />
                    </div>
                    
                    <div className="h-32 bg-slate-950 rounded border border-slate-800 p-2 shrink-0 relative">
                        <div className="absolute top-2 left-2 z-10 text-xs text-slate-500 flex items-center gap-1">
                            <Activity size={10} /> MULTI-MODAL HISTORY
                        </div>
                        <ResponsiveContainer width="100%" height="100%">
                            <LineChart data={history}>
                                <CartesianGrid strokeDasharray="3 3" stroke="#1e293b" vertical={false} />
                                <YAxis domain={[0, 1]} hide />
                                <Tooltip contentStyle={{ backgroundColor: '#020617', border: '1px solid #1e293b' }} itemStyle={{ fontSize: '10px' }} labelStyle={{ display: 'none' }} />
                                <Line type="monotone" dataKey="ST_MIZARU" stroke="#d8b4fe" dot={false} strokeWidth={2} />
                                <Line type="monotone" dataKey="ST_YES" stroke="#4ade80" dot={false} strokeWidth={1} />
                                <Line type="monotone" dataKey="ST_GRASP" stroke="#facc15" dot={false} strokeWidth={2} />
                                <Line type="monotone" dataKey="ST_PEEKABOO" stroke="#f472b6" dot={false} strokeWidth={2} />
                            </LineChart>
                        </ResponsiveContainer>
                    </div>
                </div>
            </div>
        </div>
    );
};

const root = createRoot(document.getElementById('root'));
root.render(<LogicGraphApp />);
</file>

<file path="pyproject.toml">
[build-system]
requires = ["maturin>=1.0,<2.0"]
build-backend = "maturin"

[project]
name = "context_graph_rs"
requires-python = ">=3.8"
classifiers = [
    "Programming Language :: Rust",
    "Programming Language :: Python :: Implementation :: CPython",
    "Programming Language :: Python :: Implementation :: PyPy",
]
dynamic = ["version"]
</file>

<file path="README.md">
# ContextGraph-RS: Spreading Activation Engine in Rust

![Build Status](https://img.shields.io/badge/build-passing-brightgreen)
![Rust](https://img.shields.io/badge/core-Rust-orange)
![WASM](https://img.shields.io/badge/target-WASM-blue)

**ContextGraph-RS** is a high-performance, modular core library for Context Awareness logic based on **Spreading Activation Theory (SAT)**. 

This repository is a port of the "Project V6.0" JavaScript prototype into a robust Rust codebase, enabling:
1.  **Portability**: The same logic (`ContextEngine`) runs in Browsers (WASM), Robots (ROS2/Python), and Servers.
2.  **Scalability**: Capable of handling thousands of nodes/edges with zero garbage collection overhead.
3.  **Type Safety**: Rigid state management preventing runtime errors in complex graph interactions.

## 1. Architecture

The system follows a strict separation of concerns:

* **Core (Rust)**:
    * `ContextEngine`: The "Brain". Holds the graph state (nodes, weights) and executes the sigmoid propagation logic.
    * **Input**: `HashMap<String, f32>` (Normalized Sensor Data)
    * **Output**: `HashMap<String, f32>` (Activation Levels)
    * **Logic**: Energy Injection -> Spreading (Stiffness) -> Decay -> Sigmoid Activation.

* **Frontend (JavaScript/React)**:
    * **Sensation**: MediaPipe (Hands/Face/Holistic) extracts raw physical features.
    * **Preprocessing**: Simple Moving Average (SMA) buffers sensor data.
    * **Visualization**: Cytoscape.js renders the graph state returned by WASM.

```mermaid
graph LR
    Video[Camera Input] --> MP[MediaPipe JS]
    MP --> Buffer[JS Buffer]
    Buffer --"inject(Object)"--> WASM[Rust Core]
    WASM --"step()"--> WASM
    WASM --"get_activations()"--> UI[React UI]

```

## 2. Usage

### Development

```bash
# 1. Build WASM package
wasm-pack build --target web --out-dir www/pkg

# 2. Serve Locally
cd www
python3 -m http.server 8000

```

### Production / Library Use

The core logic in `src/lib.rs` is designed to be published as a crate or Python module (`maturin`).

```rust
// Rust Example
let mut engine = ContextEngine::new();
engine.inject(sensor_data); // {"IN_VEL": 0.8, ...}
engine.step();
let results = engine.get_ranked_states();

```

## 3. Future Roadmap

* **Dynamic Graph Loading**: Load graph definitions (JSON/YAML) at runtime instead of hardcoding.
* **Hebbian Learning**: Implement weight adjustment logic (`fire together, wire together`) in Rust.
* **Python Bindings**: Add `PyO3` support for direct integration with ROS2 nodes.

---
</file>

<file path="src/lib.rs">
use std::collections::HashMap;
use wasm_bindgen::prelude::*;
use serde::Serialize;

// --- Graph Definitions (Static Configuration) ---

#[derive(Clone, Copy, PartialEq)]
enum NodeType {
    Sensor,
    Feature,
    State,
}

struct NodeDef {
    id: &'static str,
    #[allow(dead_code)]
    label: &'static str,
    node_type: NodeType,
}

struct EdgeDef {
    source: &'static str,
    target: &'static str,
    weight: f32,
}

const NODES: &[NodeDef] = &[
    // Sensors
    NodeDef { id: "IN_VEL", label: "Velocity", node_type: NodeType::Sensor },
    NodeDef { id: "IN_REL_MOV", label: "Rel. Motion", node_type: NodeType::Sensor },
    NodeDef { id: "IN_FIST", label: "Fist", node_type: NodeType::Sensor },
    NodeDef { id: "IN_PINCH", label: "Pinch", node_type: NodeType::Sensor },
    NodeDef { id: "IN_OPEN", label: "Open Hand", node_type: NodeType::Sensor },
    NodeDef { id: "IN_SCISSORS", label: "Scissors Pose", node_type: NodeType::Sensor },
    NodeDef { id: "IN_HANDS_PROX", label: "Hands Touch", node_type: NodeType::Sensor },
    NodeDef { id: "IN_OCCLUSION", label: "Face Lost+Prox", node_type: NodeType::Sensor },
    NodeDef { id: "IN_THUMB_UP", label: "Thumb UP", node_type: NodeType::Sensor },
    NodeDef { id: "IN_THUMB_DOWN", label: "Thumb DOWN", node_type: NodeType::Sensor },
    NodeDef { id: "IN_EYES_ACT", label: "Cover Eyes", node_type: NodeType::Sensor },
    NodeDef { id: "IN_EARS_ACT", label: "Cover Ears", node_type: NodeType::Sensor },
    NodeDef { id: "IN_MOUTH_GUARD", label: "Cover Mouth", node_type: NodeType::Sensor },
    NodeDef { id: "IN_SMILE", label: "Smile", node_type: NodeType::Sensor },
    NodeDef { id: "IN_MOUTH", label: "Mouth Open", node_type: NodeType::Sensor },
    NodeDef { id: "IN_FACE_PROX", label: "Hand-Face Prox", node_type: NodeType::Sensor },

    // Features
    NodeDef { id: "FT_ACTIVE", label: "High Kinetic", node_type: NodeType::Feature },
    NodeDef { id: "FT_HOLDING", label: "Holding", node_type: NodeType::Feature },
    NodeDef { id: "FT_FRICTION", label: "Friction", node_type: NodeType::Feature },
    NodeDef { id: "FT_HIDING", label: "Concealment", node_type: NodeType::Feature },
    NodeDef { id: "FT_RPS_ROCK", label: "Pose: ROCK", node_type: NodeType::Feature },
    NodeDef { id: "FT_RPS_SCI", label: "Pose: SCISSORS", node_type: NodeType::Feature },
    NodeDef { id: "FT_RPS_PAP", label: "Pose: PAPER", node_type: NodeType::Feature },
    NodeDef { id: "FT_APPROVAL", label: "Semantics: YES", node_type: NodeType::Feature },
    NodeDef { id: "FT_DISAPPROVAL", label: "Semantics: NO", node_type: NodeType::Feature },
    NodeDef { id: "FT_HIDDEN_SENSE", label: "Blocking Senses", node_type: NodeType::Feature },
    NodeDef { id: "FT_HAPPY", label: "Emo: Happy", node_type: NodeType::Feature },
    NodeDef { id: "FT_SHOCK", label: "Emo: Shock", node_type: NodeType::Feature },

    // States
    NodeDef { id: "ST_IDLE", label: "IDLE", node_type: NodeType::State },
    NodeDef { id: "ST_GRASP", label: "ACTION: GRASP", node_type: NodeType::State },
    NodeDef { id: "ST_DRAG", label: "ACTION: DRAG", node_type: NodeType::State },
    NodeDef { id: "ST_WASH", label: "ACTION: WASH", node_type: NodeType::State },
    NodeDef { id: "ST_PEEKABOO", label: "CTX: HIDDEN", node_type: NodeType::State },
    NodeDef { id: "ST_ROCK", label: "GAME: ROCK", node_type: NodeType::State },
    NodeDef { id: "ST_SCISSORS", label: "GAME: SCISSORS", node_type: NodeType::State },
    NodeDef { id: "ST_PAPER", label: "GAME: PAPER", node_type: NodeType::State },
    NodeDef { id: "ST_YES", label: "CTX: YES / OK", node_type: NodeType::State },
    NodeDef { id: "ST_NO", label: "CTX: NO / BAD", node_type: NodeType::State },
    NodeDef { id: "ST_MIZARU", label: "ğŸ™ˆ MIZARU", node_type: NodeType::State },
    NodeDef { id: "ST_KIKAZARU", label: "ğŸ™‰ KIKAZARU", node_type: NodeType::State },
    NodeDef { id: "ST_IWAZARU", label: "ğŸ™Š IWAZARU", node_type: NodeType::State },
    NodeDef { id: "ST_SMILE", label: "FACE: SMILE", node_type: NodeType::State },
    NodeDef { id: "ST_SURPRISE", label: "FACE: SURPRISE", node_type: NodeType::State },
];

const EDGES: &[EdgeDef] = &[
    // V5 Physical
    EdgeDef { source: "IN_VEL", target: "FT_ACTIVE", weight: 0.9 },
    EdgeDef { source: "IN_FIST", target: "FT_HOLDING", weight: 0.9 },
    EdgeDef { source: "IN_PINCH", target: "FT_HOLDING", weight: 0.8 },
    EdgeDef { source: "IN_HANDS_PROX", target: "FT_FRICTION", weight: 0.7 },
    EdgeDef { source: "IN_REL_MOV", target: "FT_FRICTION", weight: 0.9 },
    EdgeDef { source: "IN_OCCLUSION", target: "FT_HIDING", weight: 1.0 },
    
    EdgeDef { source: "FT_HOLDING", target: "ST_GRASP", weight: 1.0 },
    EdgeDef { source: "FT_ACTIVE", target: "ST_GRASP", weight: -0.3 },
    EdgeDef { source: "FT_HOLDING", target: "ST_DRAG", weight: 0.8 },
    EdgeDef { source: "FT_ACTIVE", target: "ST_DRAG", weight: 0.9 },
    EdgeDef { source: "FT_FRICTION", target: "ST_WASH", weight: 1.2 },
    EdgeDef { source: "FT_HIDING", target: "ST_PEEKABOO", weight: 1.2 },

    // V4 Semantic
    EdgeDef { source: "IN_FIST", target: "FT_RPS_ROCK", weight: 0.8 },
    EdgeDef { source: "IN_SCISSORS", target: "FT_RPS_SCI", weight: 0.9 },
    EdgeDef { source: "IN_OPEN", target: "FT_RPS_PAP", weight: 0.9 },
    EdgeDef { source: "FT_RPS_ROCK", target: "ST_ROCK", weight: 0.9 },
    EdgeDef { source: "FT_RPS_SCI", target: "ST_SCISSORS", weight: 0.9 },
    EdgeDef { source: "FT_RPS_PAP", target: "ST_PAPER", weight: 0.9 },

    EdgeDef { source: "IN_THUMB_UP", target: "FT_APPROVAL", weight: 1.0 },
    EdgeDef { source: "IN_THUMB_DOWN", target: "FT_DISAPPROVAL", weight: 1.0 },
    EdgeDef { source: "IN_THUMB_UP", target: "FT_RPS_ROCK", weight: -0.5 },
    EdgeDef { source: "IN_THUMB_DOWN", target: "FT_RPS_ROCK", weight: -0.5 },
    EdgeDef { source: "FT_APPROVAL", target: "ST_YES", weight: 1.0 },
    EdgeDef { source: "FT_DISAPPROVAL", target: "ST_NO", weight: 1.0 },

    EdgeDef { source: "IN_EYES_ACT", target: "FT_HIDDEN_SENSE", weight: 0.8 },
    EdgeDef { source: "IN_EYES_ACT", target: "ST_MIZARU", weight: 1.0 },
    EdgeDef { source: "IN_HANDS_PROX", target: "ST_MIZARU", weight: 0.5 },
    EdgeDef { source: "IN_EARS_ACT", target: "FT_HIDDEN_SENSE", weight: 0.8 },
    EdgeDef { source: "IN_EARS_ACT", target: "ST_KIKAZARU", weight: 1.0 },
    EdgeDef { source: "IN_MOUTH_GUARD", target: "FT_HIDDEN_SENSE", weight: 0.8 },
    EdgeDef { source: "IN_MOUTH_GUARD", target: "ST_IWAZARU", weight: 1.0 },
    EdgeDef { source: "IN_HANDS_PROX", target: "ST_IWAZARU", weight: 0.8 },

    EdgeDef { source: "IN_SMILE", target: "FT_HAPPY", weight: 0.9 },
    EdgeDef { source: "IN_MOUTH", target: "FT_SHOCK", weight: 0.6 },
    EdgeDef { source: "IN_FACE_PROX", target: "FT_SHOCK", weight: 0.5 },
    EdgeDef { source: "FT_HAPPY", target: "ST_SMILE", weight: 0.9 },
    EdgeDef { source: "FT_SHOCK", target: "ST_SURPRISE", weight: 0.9 },

    // Inhibition
    EdgeDef { source: "FT_ACTIVE", target: "ST_IDLE", weight: -0.6 },
    EdgeDef { source: "ST_ROCK", target: "ST_SCISSORS", weight: -0.8 },
    EdgeDef { source: "ST_ROCK", target: "ST_PAPER", weight: -0.8 },
    EdgeDef { source: "ST_SCISSORS", target: "ST_PAPER", weight: -0.8 },
    EdgeDef { source: "ST_YES", target: "ST_NO", weight: -2.0 },
    EdgeDef { source: "ST_NO", target: "ST_YES", weight: -2.0 },
    EdgeDef { source: "ST_MIZARU", target: "ST_KIKAZARU", weight: -1.0 },
    EdgeDef { source: "ST_MIZARU", target: "ST_IWAZARU", weight: -1.0 },
    EdgeDef { source: "ST_KIKAZARU", target: "ST_IWAZARU", weight: -1.0 },
    EdgeDef { source: "ST_GRASP", target: "ST_WASH", weight: -0.8 },
    EdgeDef { source: "ST_WASH", target: "ST_GRASP", weight: -0.8 },
    EdgeDef { source: "ST_DRAG", target: "ST_WASH", weight: -0.8 },
];

// --- Engine ---

// Helper struct for sorting states (moved outside impl)
#[derive(Serialize)]
struct RankedState {
    id: String,
    label: String,
    value: f32,
}

#[wasm_bindgen]
pub struct ContextEngine {
    nodes: HashMap<String, f32>,
    node_types: HashMap<String, NodeType>,
    // ã‚¨ãƒƒã‚¸ã®æ¤œç´¢ã‚’é«˜é€ŸåŒ–ã™ã‚‹ãŸã‚ã€Targetã‚’ã‚­ãƒ¼ã«ã—ãŸMapã‚’æŒã¤
    edges_by_target: HashMap<String, Vec<(&'static str, f32)>>, 
    
    decay: f32,
    stiffness: f32,
}

#[wasm_bindgen]
impl ContextEngine {
    #[wasm_bindgen(constructor)]
    pub fn new() -> Self {
        #[cfg(feature = "console_error_panic_hook")]
        console_error_panic_hook::set_once();

        let mut nodes = HashMap::new();
        let mut node_types = HashMap::new();
        let mut edges_by_target: HashMap<String, Vec<(&str, f32)>> = HashMap::new();

        for n in NODES {
            nodes.insert(n.id.to_string(), 0.0);
            node_types.insert(n.id.to_string(), n.node_type);
        }

        for e in EDGES {
            edges_by_target
                .entry(e.target.to_string())
                .or_default()
                .push((e.source, e.weight));
        }

        Self {
            nodes,
            node_types,
            edges_by_target,
            decay: 0.25,
            stiffness: 0.6,
        }
    }

    fn sigmoid(&self, x: f32) -> f32 {
        1.0 / (1.0 + (-6.0 * (x - 0.5)).exp())
    }

    // JSã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ { "IN_VEL": 0.5, ... } ã‚’å—ã‘å–ã‚‹
    pub fn inject(&mut self, inputs: JsValue) {
        let input_map: HashMap<String, f32> = serde_wasm_bindgen::from_value(inputs).unwrap_or_default();
        
        for (id, val) in input_map {
            if let Some(current) = self.nodes.get_mut(&id) {
                // V5 Logic: Slight blend
                *current = (*current * 0.3) + (val * 0.7);
            }
        }
    }

    pub fn step(&mut self) {
        let mut next_state = self.nodes.clone();

        for (node_id, current_val) in &self.nodes {
            let mut input_sum = 0.0;

            // Gather energy from incoming edges
            if let Some(incoming) = self.edges_by_target.get(node_id) {
                for (source_id, weight) in incoming {
                    if let Some(source_val) = self.nodes.get(*source_id) {
                        input_sum += source_val * weight;
                    }
                }
            }

            let energy = input_sum * self.stiffness;
            let retained = current_val * (1.0 - self.decay);
            let node_type = self.node_types.get(node_id).unwrap();

            match node_type {
                NodeType::Sensor => {
                    // Sensors just retain/decay (values are injected externally)
                    next_state.insert(node_id.clone(), (retained).max(0.0));
                },
                _ => {
                    let raw_activ = retained + energy;
                    let new_val = if raw_activ > 0.1 {
                        self.sigmoid(raw_activ)
                    } else {
                        raw_activ
                    };
                    // Clamp [0, 1]
                    next_state.insert(node_id.clone(), new_val.max(0.0).min(1.0));
                }
            }
        }

        self.nodes = next_state;
    }

    pub fn get_activations(&self) -> JsValue {
        serde_wasm_bindgen::to_value(&self.nodes).unwrap()
    }

    // Stateã‚¿ã‚¤ãƒ—ã®ãƒãƒ¼ãƒ‰ã®ã¿ã‚’ã‚½ãƒ¼ãƒˆã—ã¦è¿”ã™ï¼ˆä¸Šä½ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆåˆ¤å®šç”¨ï¼‰
    pub fn get_ranked_states(&self) -> JsValue {
        let mut states = Vec::new();
        for (id, val) in &self.nodes {
            if let Some(NodeType::State) = self.node_types.get(id) {
                // Labelæ¤œç´¢
                let label = NODES.iter().find(|n| n.id == id).map(|n| n.label).unwrap_or(id);
                
                states.push(RankedState {
                    id: id.clone(),
                    label: label.to_string(),
                    value: *val,
                });
            }
        }
        
        // Sort descending
        states.sort_by(|a, b| {
            b.value.partial_cmp(&a.value).unwrap()
        });

        serde_wasm_bindgen::to_value(&states).unwrap()
    }
}
</file>

<file path="Cargo.toml">
[package]
name = "context-graph-rs"
version = "0.1.0"
edition = "2021"
authors = ["R&D Researcher <funmatu@gmail.com>"]
description = "A dual-runtime computation core for WebAssembly and Python, powered by Rust."

[lib]
name = "context_graph_rs"
crate-type = ["cdylib", "rlib"]

[features]
default = ["console_error_panic_hook"]
wasm = ["dep:wasm-bindgen"]
python = ["dep:pyo3"]

[dependencies]
# Common dependencies (Math, etc.)
serde = { version = "1.0", features = ["derive"] }

# Feature: WebAssembly
wasm-bindgen = { version = "0.2", optional = true }

# Feature: Python
pyo3 = { version = "0.20", features = ["extension-module"], optional = true }

rayon = "1.10"
serde-wasm-bindgen = "0.6"
getrandom = { version = "0.2", features = ["js"] }
console_error_panic_hook = { version = "0.1.6", optional = true }

[profile.release]
lto = true
opt-level = 3
codegen-units = 1
</file>

</files>
